#include <buffer_handle/helper.hpp> // pad_left() pad_right()

namespace buffer_handle
{
  namespace details
  {
    template<config Config, align Align, action Action,
	     class Element, class Separator, typename Iterator> inline
    char * container_process(char * buffer, const Iterator & begin, const Iterator & end,
			     Element & element, Separator & separator)
    {
      for(Iterator current = begin; current != end; ++current)
	{
	  if(Align == align::left)
	    {
	      if(current != begin)
		{
		  buffer = separator.template handle<Config, Action>(buffer);
		}

	      buffer = element.template handle<Config, Action>(buffer, *current);
	    }
	  else if(Align == align::right)
	    {
	      if(current != begin)
		{
		  buffer -= (std::size_t)separator.template handle<Config, action::size>(nullptr);

		  separator.template handle<Config, Action>(buffer);
		}

	      buffer -= (std::size_t)element.template handle<Config, action::size>(nullptr, *current);

	      element.template handle<Config, Action>(buffer, *current);
	    }
	}

      return buffer;
    }

    template<config Config, align Align, char Pad, action Action,
	     class Element, class Separator, typename Iterator, bool UsePreviousLength> inline
    char * container(char * buffer, const Iterator & begin, const Iterator & end, std::size_t max_length,
		     Element & element, Separator & separator, std::size_t & previous_length)
    {
      if(Config == config::static_)
	{
	  if(Align == align::right)
	    {
	      buffer += -(std::size_t)details::container_process<config::static_, Align, action::size, Element, Separator, Iterator>(nullptr, begin, end, element, separator);
	    }

	  char * local = buffer;

	  if(Action == action::prepare)
	    {
	      local = details::container_process<Config, Align, Action, Element, Separator, Iterator>(local, begin, end, element, separator);
	    }

	  if(Align == align::left)
	    {
	      buffer = local;
	    }
	}
      else if(Config == config::dynamic)
	{
	  switch(Action)
	    {
	    case action::prepare:
	      {
		if(UsePreviousLength)
		  {
		    previous_length = max_length;
		  }
	      }
	    case action::reset:
	      {
		reset<Align, UsePreviousLength, Pad, std::size_t>(buffer, max_length, previous_length);

		break;
	      }
	    case action::write:
	      {
		std::size_t current_length = 0;

		if(Align == align::left)
		  {
		    char * local = details::container_process<Config, Align, Action, Element, Separator, Iterator>(buffer, begin, end, element, separator);

		    pad_right<UsePreviousLength, Pad>(buffer, local, max_length, previous_length);
		  }
		else if(Align == align::right)
		  {
		    char * local = details::container_process<Config, Align, Action, Element, Separator, Iterator>(buffer + max_length, begin, end, element, separator);

		    pad_left<UsePreviousLength, Pad>(buffer, local, max_length, previous_length);
		  }
	      }
	    }

	  buffer += max_length;
	}

      return buffer;
    }
  };

  template<config Config, align Align, char Pad, action Action,
	   class Element, class Separator, typename Iterator> inline
  char * container(char * buffer, const Iterator & begin, const Iterator & end, std::size_t max_length,
		   Element & element, Separator & separator, std::size_t & previous_length)
  {
    return details::container<Config, Align, Pad, Action, Element, Separator, Iterator, true>
      (buffer, begin, end, max_length, element, separator, previous_length);
  }

  template<config Config, align Align, char Pad, action Action,
	   class Element, class Separator, typename Iterator> inline
  char * container(char * buffer, const Iterator & begin, const Iterator & end, std::size_t max_length,
		   Element & element, Separator & separator)
  {
    return details::container<Config, Align, Pad, Action, Element, Separator, Iterator, false>
      (buffer, begin, end, max_length, element, separator, max_length);
  }

  template<config Config, align Align, char Pad, bool IsLong> inline
  container_t<Config, Align, Pad, IsLong>::container_t() :
    max_length(0)
  {

  }

  template<config Config, align Align, char Pad, bool IsLong> inline
  void container_t<Config, Align, Pad, IsLong>::set_max_length(std::size_t length)
  {
    this->max_length = length;
  }

  template<config Config, align Align, char Pad, bool IsLong>
  template<action Action, class Iterator, class Element, class Separator> inline
  char * container_t<Config, Align, Pad, IsLong>::handle(char * buffer, const Iterator & begin, const Iterator & end, Element & element, Separator & separator)
  {
    return container<Config, Align, Pad, Action, Element, Separator, Iterator>(buffer, begin, end, this->max_length, element, separator);
  }

  template<config Config, align Align, char Pad> inline
  container_t<Config, Align, Pad, true>::container_t() :
    previous_length(0)
  {

  }

  template<config Config, align Align, char Pad> inline
  void container_t<Config, Align, Pad, true>::set_max_length(std::size_t length)
  {
    this->max_length = length;
  }

  template<config Config, align Align, char Pad>
  template<action Action, class Iterator, class Element, class Separator> inline
  char * container_t<Config, Align, Pad, true>::handle(char * buffer, const Iterator & begin, const Iterator & end, Element & element, Separator & separator)
  {
    return container<Config, Align, Pad, Action, Element, Separator, Iterator>(buffer, begin, end, this->max_length, element, separator, this->previous_length);
  }
};
