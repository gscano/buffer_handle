#include <cstring> // memset()

namespace buffer_handle
{
  namespace details
  {
    template<config Config, align Align, action Action,
	     typename Iterator, class Element, class Separator> inline
    char * container_process(char * buffer, const Iterator & begin, const Iterator & end,
			     Element & element, Separator & separator)
    {
      for(Iterator current = begin; current != end; ++current)
	{
	  if(Align == align::left)
	    {
	      if(current != begin)
		{
		  buffer = separator.template handle<Config, Action>(buffer);
		}

	      buffer = element.template handle<Config, Action>(buffer, current);
	    }
	  else if(Align == align::right)
	    {
	      if(current != begin)
		{
		  buffer -= (std::size_t)separator.template handle<Config, action::size>(nullptr);

		  separator.template handle<Config, Action>(buffer);
		}

	      buffer -= (std::size_t)element.template handle<Config, action::size>(nullptr, current);

	      element.template handle<Config, Action>(buffer, current);
	    }
	}

      return buffer;
    }
  };

  template<config Config, align Align, char Pad, action Action,
	   typename Iterator, class Element, class Separator> inline
  char * container(char * buffer, const Iterator & begin, const Iterator & end, std::size_t max_length,
		   Element & element, Separator & separator)
  {
    if(Config == config::static_)
      {
	if(Align == align::right)
	  {
	    buffer += -(std::size_t)details::container_process<config::static_, Align, action::size>(nullptr, begin, end, element, separator);
	  }

	char * local = buffer;

	if(Action == action::prepare)
	  {
	    local = details::container_process<Config, Align, Action>(local, begin, end, element, separator);
	  }

	if(Align == align::left)
	  {
	    buffer = local;
	  }
      }
    else if(Config == config::dynamic)
      {
	switch(Action)
	  {
	  case action::prepare:
	  case action::write:
	  case action::reset:
	    {
	      if(Align == align::left)
		{
		  char * local = details::container_process<Config, Align, Action>(buffer, begin, end, element, separator);
		  std::memset(local, Pad, max_length - (local - buffer));
		}
	      else if(Align == align::right)
		{
		  char * local = details::container_process<Config, Align, Action>(buffer + max_length, begin, end, element, separator);
		  std::memset(buffer, Pad, local - buffer);
		}
	    }
	  }

	buffer += max_length;
      }

    return buffer;
  }

  template<config Config, align Align, char Pad, class Element, class Separator> inline
  container_t<Config, Align, Pad, Element, Separator>::container_t(std::size_t max_length, const Element & element /* = Element() */, const Separator & separator /* = Separator() */) :
    max_length(max_length),
    element(element),
    separator(separator)
  {

  }

  template<config Config, align Align, char Pad, class Element, class Separator>
  template<action Action, class Iterator> inline
  char * container_t<Config, Align, Pad, Element, Separator>::handle(char * buffer, const Iterator & begin, const Iterator & end)
  {
    return container<Config, Align, Pad, Action, Iterator, Element, Separator>(buffer, begin, end, this->max_length, this->element, this->separator);
  }
};
