#include <cassert> // assert()
#include <cstring> // memcpy() memset()

#include <buffer_handle/helper.hpp> // must_write()

namespace buffer_handle
{
  template<config Config, action Action> inline
  char * string(char * buffer, const char * value, std::size_t length)
  {
    if(must_write<Config, Action>())
      {
	std::memcpy(buffer, value, length);
      }

    return buffer + length;
  }

  namespace details
  {
    template<config Config, align Align, char Pad, action Action, bool UsePreviousLength> inline
    char * string(char * buffer, const char * value, std::size_t length, std::size_t max_length, std::size_t & previous_length)
    {
      if(Config == config::static_)
	{
	  if(Action == action::prepare)
	    {
	      assert(value != nullptr && "A static string requires a non null value initializer.");

	      std::memcpy(buffer, value, length);
	    }

	  buffer += length;
	}
      else if(Config == config::dynamic)
	{
	  switch(Action)
	    {
	    case action::size:
	      {
		return buffer + max_length;
	      }
	    case action::prepare:
	      {
		if(UsePreviousLength)
		  {
		    previous_length = max_length;
		  }
	      }
	    case action::write:
	    case action::reset:
	      {
		if(value == nullptr)
		  {
		    std::memset(buffer, Pad, max_length);

		    if(UsePreviousLength)
		      {
			previous_length = 0;
		      }
		  }
		else
		  {
		    assert(length <= max_length);

		    if(Align == align::left)
		      {
			std::memcpy(buffer, value, length);

			pad_right<UsePreviousLength, Pad>(buffer, buffer + length, max_length, previous_length);
		      }
		    else if(Align == align::right)
		      {
			char * local = buffer + max_length - length;

			std::memcpy(local, value, length);

			pad_left<UsePreviousLength, Pad>(buffer, local, max_length, previous_length);
		      }
		  }
	      }
	    }

	  buffer += max_length;
	}

      return buffer;
    }
  };

  template<config Config, align Align, char Pad, action Action> inline
  char * string(char * buffer, const char * value, std::size_t length, std::size_t max_length, std::size_t & previous_length)
  {
    return details::string<Config, Align, Pad, Action, true>(buffer, value, length, max_length, previous_length);
  }

  template<config Config, align Align, char Pad, action Action> inline
  char * string(char * buffer, const char * value, std::size_t length, std::size_t max_length)
  {
    return details::string<Config, Align, Pad, Action, false>(buffer, value, length, max_length, max_length);
  }

  template<config Config, align Align, char Pad> inline
  string_t<Config, Align, Pad>::string_t() :
    max_length(0)
  {

  }

  template<config Config, align Align, char Pad>
  template<action Action> inline
  char * string_t<Config, Align, Pad>::handle(char * buffer, const char * value, std::size_t length)
  {
    if(Config == config::dynamic && ((this->max_length == 0 && Action == action::size)
				     || Action == action::prepare))
      {
	this->max_length = length;
      }

    return string<Config, Align, Pad, Action>(buffer, value, length, this->max_length);
  }

  template<config Config, align Align, char Pad> inline
  long_string_t<Config, Align, Pad>::long_string_t() :
    previous_length(0)
  {

  }

  template<config Config, align Align, char Pad>
  template<action Action> inline
  char * long_string_t<Config, Align, Pad>::handle(char * buffer, const char * value, std::size_t length)
  {
    if(Config == config::dynamic && ((this->max_length == 0 && Action == action::size)
				     || Action == action::prepare))
      {
	this->max_length = length;
      }

    return string<Config, Align, Pad, Action>(buffer, value, length, this->max_length, this->previous_length);
  }
};
