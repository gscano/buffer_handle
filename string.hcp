#include <cassert> // assert()
#include <cstring> // memcpy() memset()

#include <buffer_handle/helper.hpp> // must_write()

namespace buffer_handle
{
  template<config Config, action Action> inline
  char * string(char * buffer, const char * value, std::size_t length)
  {
    if(must_write<Config, Action>())
      {
	std::memcpy(buffer, value, length);
      }

    return buffer + length;
  }

  template<config Config, align Align, char Pad, action Action> inline
  char * string(char * buffer, const char * value, std::size_t length, std::size_t max_length, std::size_t & previous_length)
  {
    if(Config == config::static_)
      {
	if(Action == action::prepare)
	  {
	    assert(value != nullptr && "A static string requires a non null value initializer.");

	    std::memcpy(buffer, value, length);
	  }

	buffer += length;
      }
    else if(Config == config::dynamic)
      {
	switch(Action)
	  {
	  case action::size:
	    {
	      return buffer + max_length;
	    }
	  case action::prepare:
	    {
	      previous_length = max_length;
	    }
	  case action::write:
	  case action::reset:
	    {
	      if(value == nullptr)
		{
		  std::memset(buffer, Pad, max_length);

		  previous_length = 0;
		}
	      else
		{
		  assert(length <= max_length);
		  assert(previous_length <= max_length);

		  if(Align == align::left)
		    {
		      std::memcpy(buffer, value, length);

		      if(length < previous_length)
			{
			  std::memset(buffer + length, Pad, previous_length - length);
			}
		    }
		  else if(Align == align::right)
		    {
		      if(length < previous_length)
			{
			  std::memset(buffer + max_length - previous_length, Pad, previous_length - length);
			}

		      std::memcpy(buffer + max_length - length, value, length);
		    }

		  previous_length = length;
		}
	    }
	  }

	buffer += max_length;
      }

    return buffer;
  }

  template<config Config, align Align, char Pad, action Action> inline
  char * string(char * buffer, const char * value, std::size_t length, std::size_t max_length)
  {
    return string<Config, Align, Pad, Action>(buffer, value, length, max_length, max_length);
  }

  template<config Config, align Align, char Pad> inline
  string_t<Config, Align, Pad>::string_t(std::size_t max_length, const char * value /* = nullptr */, std::size_t length /* = 0 */) :
    value(value),
    length(length),
    max_length(max_length)
  {

  }

  template<config Config, align Align, char Pad>
  template<action Action> inline
  char * string_t<Config, Align, Pad>::handle(char * buffer) const
  {
    return string<Config, Action, Align, Pad>(buffer, this->value, this->length, this->max_length);
  }

  template<config Config, align Align, char Pad> inline
  recycled_string_t<Config, Align, Pad>::recycled_string_t(std::size_t max_length, const char * value /* = nullptr */, std::size_t length /* = 0 */) :
    string_t<Config, Align, Pad>(max_length, value, length),
    previous_length(max_length)
  {

  }

  template<config Config, align Align, char Pad>
  template<action Action> inline
  char * recycled_string_t<Config, Align, Pad>::handle(char * buffer) const
  {
    return string<Config, Action, Align, Pad>(buffer, this->value, this->length, this->max_length, this->previous_length);
  }
};
