#include <cassert> // assert()
#include <cstring> // memset()
#include <type_traits> // is_integral is_signed

#include <buffer_handle/helper.hpp> // must_write()

namespace buffer_handle
{
  template<config Config, char InsteadOfALeadingZero, action Action, typename I> inline
  char * two_digits_number(char * buffer, I i)
  {
    static_assert(std::is_integral<I>::value, "Template parameter I must be an integral type.");
    assert(0 <= i);

    if(must_write<Config, Action>())
      {
	buffer[0] = '0' + i / 10;
	buffer[1] = '0' + i - 10 * (buffer[0] - '0');

	if(InsteadOfALeadingZero != 0 && buffer[0] == '0')
	  {
	    buffer[0] = InsteadOfALeadingZero;
	  }
      }

    return buffer + 2;
  }

  template<config Config, action Action, typename I> inline
  char * four_digits_number(char * buffer, I i)
  {
    static_assert(std::is_integral<I>::value, "Template parameter I must be an integral type.");
    assert(0 <= i);

    if(must_write<Config, Action>())
      {
	buffer[0] = '0' + i / 1000;
	i = i - 1000 * (buffer[0] - '0');
	buffer[1] = '0' + i / 100;
	i = i - 100 * (buffer[1] - '0');
	buffer[2] = '0' + i / 10;
	i = i - 10 * (buffer[2] - '0');
	buffer[3] = '0' + i;
      }

    return buffer + 4;
  }

  namespace details
  {
    template<class T>
    constexpr uint8_t digits(T number, bool no_digits = true);
  }

  template<config Config, align Align, char Pad, class Itoa, action Action, typename I, typename MaxDigits> inline
  char * integral_number(char * buffer, I i, MaxDigits & max_digits, const Itoa & itoa /* = Itoa() */)
  {
    static_assert(std::is_integral<I>::value, "Template parameter T must be an integral type.");

    if(Config == config::static_)
      {
	if(Action == action::prepare)
	  {
	    max_digits = details::digits(i);
	    itoa.template fwd<I>(buffer, i);
	  }

	buffer += details::digits(i);
      }
    else if(Config == config::dynamic)
      {
	switch(Action)
	  {
	  case action::size:
	    {
	      return buffer + details::digits(i);
	    }
	  case action::prepare:
	    {
	      max_digits = details::digits(i);
	    }
	  case action::write:
	  case action::reset:
	    {
	      if(Align == align::left)
		{
		  char * local = itoa.template fwd<I>(buffer, i);
		  std::memset(local, Pad, max_digits - (local - buffer));
		}
	      else if(Align == align::right)
		{
		  char * local = itoa.template bwd<I>(buffer + max_digits, i);
		  std::memset(buffer, Pad, local - buffer);
		}
	    }
	  }

	buffer += max_digits;
      }

    return buffer;
  }

  template<config Config, align Align, char Pad, class Itoa, typename I, typename MaxDigits> inline
  integral_number_t<Config, Align, Pad, Itoa, I, MaxDigits>::integral_number_t(I i /* = I() */) :
    value(i),
    max_digits(0)
  {

  }

  template<config Config, align Align, char Pad, class Itoa, typename I, typename MaxDigits>
  template<action Action> inline
  char * integral_number_t<Config, Align, Pad, Itoa, I, MaxDigits>::handle(char * buffer, const Itoa & itoa /* = Itoa() */)
  {
    return integral_number<Config, Align, Pad, Itoa, Action, I, MaxDigits>(buffer, this->value, this->max_digits, itoa);
  }

  namespace details
  {
    template<class T> inline
    constexpr uint8_t digits(T number, bool no_digits)
    {
      static_assert(std::is_integral<T>::value, "Template parameter T must be an integral type.");

      return
	(number == 0
	 ?
	 no_digits
	 :
	 (number < 0 && no_digits) + 1 + digits<T>(number / 10, false)
	 );
      ;
    }
  };
};
