#include <cassert> // assert()
#include <type_traits> // is_integral is_signed

#include <buffer_handle/helper.hpp> // must_write()

namespace buffer_handle
{
  template<config Config, char InsteadOfALeadingZero, action Action, typename I> inline
  char * two_digits_number(char * buffer, I i)
  {
    static_assert(std::is_integral<I>::value, "Template parameter I must be an integral type.");
    assert(0 <= i);

    if(must_write<Config, Action>())
      {
	buffer[0] = '0' + i / 10;
	buffer[1] = '0' + i - 10 * (buffer[0] - '0');

	if(InsteadOfALeadingZero != 0 && buffer[0] == '0')
	  {
	    buffer[0] = InsteadOfALeadingZero;
	  }
      }

    return buffer + 2;
  }

  template<config Config, action Action, typename I> inline
  char * four_digits_number(char * buffer, I i)
  {
    static_assert(std::is_integral<I>::value, "Template parameter I must be an integral type.");
    assert(0 <= i);

    if(must_write<Config, Action>())
      {
	buffer[0] = '0' + i / 1000;
	i = i - 1000 * (buffer[0] - '0');
	buffer[1] = '0' + i / 100;
	i = i - 100 * (buffer[1] - '0');
	buffer[2] = '0' + i / 10;
	i = i - 10 * (buffer[2] - '0');
	buffer[3] = '0' + i;
      }

    return buffer + 4;
  }

  namespace details
  {
    template<class T>
    constexpr uint8_t digits(T number, bool no_digits = true);
  }

  namespace details
  {
    template<config Config, align Align, char Pad, action Action, class Itoa, typename I, typename MaxDigits, bool UsePreviousDigits> inline
    char * integral_number(char * buffer, I i, MaxDigits & max_digits, const Itoa & itoa, MaxDigits & previous_digits)
    {
      static_assert(std::is_integral<I>::value, "Template parameter T must be an integral type.");

      if(Config == config::static_)
	{
	  if(Action == action::prepare)
	    {
	      max_digits = details::digits(i);
	      itoa.template fwd<I>(buffer, i);
	    }

	  buffer += details::digits(i);
	}
      else if(Config == config::dynamic)
	{
	  switch(Action)
	    {
	    case action::size:
	      {
		return buffer + details::digits(i);
	      }
	    case action::prepare:
	      {
		max_digits = details::digits(i);

		if(UsePreviousDigits)
		  {
		    previous_digits = 0;
		  }
	      }
	    case action::write:
	    case action::reset:
	      {
		assert(previous_digits <= max_digits);

		MaxDigits current_digits = 0;

		if(Align == align::left)
		  {
		    char * local = itoa.template fwd<I>(buffer, i);

		    pad_right<UsePreviousDigits, Pad>(buffer, local, max_digits, previous_digits);
		  }
		else if(Align == align::right)
		  {
		    char * local = itoa.template bwd<I>(buffer + max_digits, i);

		    pad_left<UsePreviousDigits, Pad>(buffer, local, max_digits, previous_digits);
		  }
	      }
	    }

	  buffer += max_digits;
	}

      return buffer;
    }
  };

  template<config Config, align Align, char Pad, action Action, class Itoa, typename I, typename MaxDigits = uint8_t>
  char * integral_number(char * buffer, I i, MaxDigits & max_digits, MaxDigits & previous_digits, const Itoa & itoa)
  {
    return details::integral_number<Config, Align, Pad, Action, Itoa, I, MaxDigits, true>(buffer, i, max_digits, itoa, previous_digits);
  }

  template<config Config, align Align, char Pad, action Action, class Itoa, typename I, typename MaxDigits = uint8_t>
  char * integral_number(char * buffer, I i, MaxDigits & max_digits, const Itoa & itoa)
  {
    return details::integral_number<Config, Align, Pad, Action, Itoa, I, MaxDigits, false>(buffer, i, max_digits, itoa, max_digits);
  }

  template<config Config, align Align, char Pad, typename I, typename MaxDigits, bool IsLong> inline
  integral_number_t<Config, Align, Pad, I, MaxDigits, IsLong>::integral_number_t() :
    max_digits(0)
  {

  }

  template<config Config, align Align, char Pad, typename I, typename MaxDigits, bool IsLong>
  template<action Action, class Itoa> inline
  char * integral_number_t<Config, Align, Pad, I, MaxDigits, IsLong>::handle(char * buffer, I value, const Itoa & itoa /* = Itoa() */)
  {
    return integral_number<Config, Align, Pad, Action, Itoa, I, MaxDigits>(buffer, value, this->max_digits, itoa);
  }

  template<config Config, align Align, char Pad, typename I, typename MaxDigits> inline
  integral_number_t<Config, Align, Pad, I, MaxDigits, true>::integral_number_t() :
    previous_digits(0)
  {

  }

  template<config Config, align Align, char Pad, typename I, typename MaxDigits>
  template<action Action, class Itoa> inline
  char * integral_number_t<Config, Align, Pad, I, MaxDigits, true>::handle(char * buffer, I value, const Itoa & itoa /* = Itoa() */)
  {
    return integral_number<Config, Align, Pad, Action, Itoa, I, MaxDigits>(buffer, value, this->max_digits, this->previous_digits, itoa);
  }

  namespace details
  {
    template<class T> inline
    constexpr uint8_t digits(T number, bool no_digits)
    {
      static_assert(std::is_integral<T>::value, "Template parameter T must be an integral type.");

      return
	(number == 0
	 ?
	 no_digits
	 :
	 (number < 0 && no_digits) + 1 + digits<T>(number / 10, false)
	 );
      ;
    }
  };
};
